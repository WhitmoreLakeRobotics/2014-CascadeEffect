#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTServo,  none)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Motor,  mtr_S1_C1_1,     leftDriveMotor, tmotorTetrix, PIDControl, reversed, encoder)
#pragma config(Motor,  mtr_S1_C1_2,     rightDriveMotor, tmotorTetrix, PIDControl, encoder)
#pragma config(Motor,  mtr_S1_C2_1,     motorF,        tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C2_2,     armMotor,      tmotorTetrix, PIDControl, encoder)
#pragma config(Servo,  srvo_S1_C3_1,    HookLeft,             tServoStandard)
#pragma config(Servo,  srvo_S1_C3_2,    HookRight,            tServoStandard)
#pragma config(Servo,  srvo_S1_C3_3,    servo3,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_4,    servo4,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_6,    servo6,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "JoystickDriver.c"  //Include file to "handle" the Bluetooth messages.
#include "motor.h"

const int hook_up = 1;
const int hook_down = 2;
int armVal;
int EncoderVal;
const int ArmMin = 0;
const int startArmMax = 11800;
int ArmMax = startArmMax;
int leftMotor;
int rightMotor;
int halfMXAxis;
int motorXAxis;
const int absArmMax = 15000;
bool joy1_btn1Down = false;
bool joy1_btn2Down = false;

void initializeRobot()

{
	return;
}


int scaleForMotor (int joyValue){
	const int DEADZONE = 15;
	const int MAX_MOTOR_VAL = 100;
	const float MAX_JOY_VAL = 128.0;

	if(abs(joyValue) < DEADZONE){
		return 0;
	}
	int direction = joyValue / abs(joyValue);
	float ratio = (joyValue*joyValue) / (MAX_JOY_VAL * MAX_JOY_VAL);
	int scaledVal = ratio * MAX_MOTOR_VAL * direction;
	return scaledVal;
}

void incArmMax (){
	if(absArmMax > ArmMax){
		ArmMax = ArmMax + (startArmMax/90);
	}
}

void decArmMax (){
	if(startArmMax < ArmMax){
		ArmMax = ArmMax - (startArmMax/90);
	}
}

task main()
{
	initializeRobot();

	waitForStart();   // wait for start of tele-op phase

	joy1_btn1Down = (joy1Btn(1) == 1);
	joy1_btn2Down = (joy1Btn(2) == 1);

	while (true)
	{

		if((joy1Btn(1) == 1) && (!joy1_btn1Down)){
			//nxtDisplayBigTextLine(1,"BTN1=ON");
			incArmMax();
			joy1_btn1Down = true;
		}

		if((joy1Btn(1) == 0) && (joy1_btn1Down)){
			//nxtDisplayBigTextLine(1, "BTN1=OFF");
			joy1_btn1Down = false;
		}

		if((joy1Btn(2) == 1) && (!joy1_btn2Down)){
			//nxtDisplayBigTextLine(2, "BTN2=ON");
			decArmMax();
			joy1_btn2Down = true;
		}

		if((joy1Btn(2) == 0) && (joy1_btn2Down)){
			//nxtDisplayBigTextLine(2, "BTN=OFF");
			joy1_btn2Down = false;
		}

		armVal = convert_joystick_to_motor (joystick.joy2_y2);
		EncoderVal = nMotorEncoder[armMotor];
		if((EncoderVal > ArmMax && armVal < 0) ||
			 (EncoderVal < ArmMin && armVal > 0) ||
		   (EncoderVal <= ArmMax && EncoderVal >= ArmMin)){
			motor[armMotor] = armVal;
		}
		else {
			motor[armMotor] = 0;
		}

		motorXAxis = joystick.joy1_x2;
		halfMXAxis = motorXAxis / 2;
		rightMotor = scaleForMotor(joystick.joy1_y2);
		leftMotor = rightMotor; // scaleForMotor(joystick.joy1_y2);
		/*	if (leftMotor < 0){
		leftMotor = leftMotor*-leftMotor;
		}
		else{
		leftMotor = leftMotor*leftMotor;
		}
		if (rightMotor < 0) {
		rightMotor = rightMotor*-rightMotor;
		}
		else{
		rightMotor = rightMotor*rightMotor;
		} */
		rightMotor = rightMotor + halfMXAxis;
		leftMotor = leftMotor - halfMXAxis;

		nxtDisplayBigTextLine(1, "");
		nxtDisplayBigTextLine(2, "");
		motor[leftDriveMotor] = leftMotor;
		motor[rightDriveMotor] = rightMotor;

		if(joy2Btn(hook_up) == 1){
			servo[HookRight] = 20;
			servo[HookLeft] = 205;
		}
		else if(joy2Btn(hook_down) == 1){
			servo[HookRight] = 140;
			servo[HookLeft] = 75;
		}
		nxtDisplayBigTextLine(3, "%d", ArmMax);
	}
}
